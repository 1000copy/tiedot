#!/usr/bin/env bash

# Full path name of tiedot code and executable
cd `dirname $0`
export CODEBASE=`pwd`
export TIEDOT_EXEC=$CODEBASE/tiedot

# Remove remaining temp files generated by test cases
cleanup() {
	rm -rf /tmp/tiedot_test*
}

# Run go test cases in the directory
go_test_dir() {
	pushd $1 && go test && popd || exit 1
}

# Spawn N server processes at once
declare -a ipc_proc_ids
run_ipc_servers() {
	num_servers=$1
	tmp_dir=$2
	db_dir=$3
	for (( i = 0; i < $num_servers; i++ )); do
		./tiedot -mode=ipc -myrank=$i -totalrank=$num_servers -tmpdir=$tmp_dir -dbdir=$db_dir &
		ipc_proc_ids[$i]=$!
	done
	echo "RPC server PIDs: ${ipc_proc_ids[*]}"
}

# Shutdown all IPC servers
kill_ipc_servers() {
	pkill -TERM -f 'tiedot.*mode=ipc'
}

# Spawn 4 server processes then run test cases that require IPC connection.
test_network() {
	cleanup
	run_ipc_servers 4 /tmp/tiedot_test_ipc_tmp /tmp/tiedot_test_ipc_db
	go_test_dir 'network'
	kill_ipc_servers
}

# Format and compile tiedot
find . -name '*.go' -exec go fmt {} \; || exit $?
go build || exit $?

# Parse mode parameter
MODE=$1

case $MODE in
	'test-uid')
		cleanup && go_test_dir 'uid' ;;
	'test-dstruct')
		cleanup && go_test_dir 'dstruct' ;;
	'test-colpart')
		cleanup && go_test_dir 'colpart' ;;
	'test-network')
		test_network ;;
	'test-all')
		for dir in uid dstruct colpart; do
			go_test_dir $dir
		done && test_network ;;
	'run-server')
		run_ipc_servers 2 /tmp/tiedot_test_1 /tmp/tiedot_test_2
esac
